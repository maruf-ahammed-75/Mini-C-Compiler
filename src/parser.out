Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    FOR
    RETURN

Grammar

Rule 0     S' -> start
Rule 1     start -> stmt_sequence
Rule 2     stmt_sequence -> stmt_sequence stmt
Rule 3     stmt_sequence -> stmt
Rule 4     stmt -> var_decl
Rule 5     stmt -> var_assign
Rule 6     stmt -> output_stmt
Rule 7     stmt -> conditional
Rule 8     stmt -> loop
Rule 9     stmt -> code_block
Rule 10    var_decl -> data_type IDENTIFIER SEMICOLON
Rule 11    var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON
Rule 12    data_type -> INT
Rule 13    data_type -> FLOAT
Rule 14    var_assign -> IDENTIFIER EQUALS expr SEMICOLON
Rule 15    output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON
Rule 16    conditional -> IF LPAREN comparison RPAREN code_block
Rule 17    conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block
Rule 18    loop -> WHILE LPAREN comparison RPAREN code_block
Rule 19    code_block -> block_start stmt_sequence block_end
Rule 20    block_start -> LBRACE
Rule 21    block_end -> RBRACE
Rule 22    comparison -> expr rel_op expr
Rule 23    rel_op -> LESS
Rule 24    rel_op -> LESS_EQ
Rule 25    rel_op -> GREATER
Rule 26    rel_op -> GREATER_EQ
Rule 27    rel_op -> EQUAL_TO
Rule 28    rel_op -> NOT_EQUAL
Rule 29    expr -> expr PLUS term
Rule 30    expr -> expr MINUS term
Rule 31    expr -> term
Rule 32    term -> term MULTIPLY base
Rule 33    term -> term DIVIDE base
Rule 34    term -> term MOD base
Rule 35    term -> base
Rule 36    base -> INTEGER
Rule 37    base -> DECIMAL
Rule 38    base -> IDENTIFIER
Rule 39    base -> LPAREN expr RPAREN

Terminals, with rules where they appear

COMMA                : 
DECIMAL              : 37
DIVIDE               : 33
ELSE                 : 17
EQUALS               : 11 14
EQUAL_TO             : 27
FLOAT                : 13
FOR                  : 
GREATER              : 25
GREATER_EQ           : 26
IDENTIFIER           : 10 11 14 38
IF                   : 16 17
INT                  : 12
INTEGER              : 36
LBRACE               : 20
LESS                 : 23
LESS_EQ              : 24
LPAREN               : 15 16 17 18 39
MINUS                : 30
MOD                  : 34
MULTIPLY             : 32
NOT_EQUAL            : 28
PLUS                 : 29
PRINT                : 15
RBRACE               : 21
RETURN               : 
RPAREN               : 15 16 17 18 39
SEMICOLON            : 10 11 14 15
WHILE                : 18
error                : 

Nonterminals, with rules where they appear

base                 : 32 33 34 35
block_end            : 19
block_start          : 19
code_block           : 9 16 17 17 18
comparison           : 16 17 18
conditional          : 7
data_type            : 10 11
expr                 : 11 14 15 22 22 29 30 39
loop                 : 8
output_stmt          : 6
rel_op               : 22
start                : 0
stmt                 : 2 3
stmt_sequence        : 1 2 19
term                 : 29 30 31 32 33 34
var_assign           : 5
var_decl             : 4

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . stmt_sequence
    (2) stmt_sequence -> . stmt_sequence stmt
    (3) stmt_sequence -> . stmt
    (4) stmt -> . var_decl
    (5) stmt -> . var_assign
    (6) stmt -> . output_stmt
    (7) stmt -> . conditional
    (8) stmt -> . loop
    (9) stmt -> . code_block
    (10) var_decl -> . data_type IDENTIFIER SEMICOLON
    (11) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (14) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (15) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (16) conditional -> . IF LPAREN comparison RPAREN code_block
    (17) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (18) loop -> . WHILE LPAREN comparison RPAREN code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (12) data_type -> . INT
    (13) data_type -> . FLOAT
    (20) block_start -> . LBRACE

    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    LBRACE          shift and go to state 18

    start                          shift and go to state 1
    stmt_sequence                  shift and go to state 2
    stmt                           shift and go to state 3
    var_decl                       shift and go to state 4
    var_assign                     shift and go to state 5
    output_stmt                    shift and go to state 6
    conditional                    shift and go to state 7
    loop                           shift and go to state 8
    code_block                     shift and go to state 9
    data_type                      shift and go to state 10
    block_start                    shift and go to state 15

state 1

    (0) S' -> start .



state 2

    (1) start -> stmt_sequence .
    (2) stmt_sequence -> stmt_sequence . stmt
    (4) stmt -> . var_decl
    (5) stmt -> . var_assign
    (6) stmt -> . output_stmt
    (7) stmt -> . conditional
    (8) stmt -> . loop
    (9) stmt -> . code_block
    (10) var_decl -> . data_type IDENTIFIER SEMICOLON
    (11) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (14) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (15) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (16) conditional -> . IF LPAREN comparison RPAREN code_block
    (17) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (18) loop -> . WHILE LPAREN comparison RPAREN code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (12) data_type -> . INT
    (13) data_type -> . FLOAT
    (20) block_start -> . LBRACE

    $end            reduce using rule 1 (start -> stmt_sequence .)
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    LBRACE          shift and go to state 18

    stmt                           shift and go to state 19
    var_decl                       shift and go to state 4
    var_assign                     shift and go to state 5
    output_stmt                    shift and go to state 6
    conditional                    shift and go to state 7
    loop                           shift and go to state 8
    code_block                     shift and go to state 9
    data_type                      shift and go to state 10
    block_start                    shift and go to state 15

state 3

    (3) stmt_sequence -> stmt .

    IDENTIFIER      reduce using rule 3 (stmt_sequence -> stmt .)
    PRINT           reduce using rule 3 (stmt_sequence -> stmt .)
    IF              reduce using rule 3 (stmt_sequence -> stmt .)
    WHILE           reduce using rule 3 (stmt_sequence -> stmt .)
    INT             reduce using rule 3 (stmt_sequence -> stmt .)
    FLOAT           reduce using rule 3 (stmt_sequence -> stmt .)
    LBRACE          reduce using rule 3 (stmt_sequence -> stmt .)
    $end            reduce using rule 3 (stmt_sequence -> stmt .)
    RBRACE          reduce using rule 3 (stmt_sequence -> stmt .)


state 4

    (4) stmt -> var_decl .

    IDENTIFIER      reduce using rule 4 (stmt -> var_decl .)
    PRINT           reduce using rule 4 (stmt -> var_decl .)
    IF              reduce using rule 4 (stmt -> var_decl .)
    WHILE           reduce using rule 4 (stmt -> var_decl .)
    INT             reduce using rule 4 (stmt -> var_decl .)
    FLOAT           reduce using rule 4 (stmt -> var_decl .)
    LBRACE          reduce using rule 4 (stmt -> var_decl .)
    $end            reduce using rule 4 (stmt -> var_decl .)
    RBRACE          reduce using rule 4 (stmt -> var_decl .)


state 5

    (5) stmt -> var_assign .

    IDENTIFIER      reduce using rule 5 (stmt -> var_assign .)
    PRINT           reduce using rule 5 (stmt -> var_assign .)
    IF              reduce using rule 5 (stmt -> var_assign .)
    WHILE           reduce using rule 5 (stmt -> var_assign .)
    INT             reduce using rule 5 (stmt -> var_assign .)
    FLOAT           reduce using rule 5 (stmt -> var_assign .)
    LBRACE          reduce using rule 5 (stmt -> var_assign .)
    $end            reduce using rule 5 (stmt -> var_assign .)
    RBRACE          reduce using rule 5 (stmt -> var_assign .)


state 6

    (6) stmt -> output_stmt .

    IDENTIFIER      reduce using rule 6 (stmt -> output_stmt .)
    PRINT           reduce using rule 6 (stmt -> output_stmt .)
    IF              reduce using rule 6 (stmt -> output_stmt .)
    WHILE           reduce using rule 6 (stmt -> output_stmt .)
    INT             reduce using rule 6 (stmt -> output_stmt .)
    FLOAT           reduce using rule 6 (stmt -> output_stmt .)
    LBRACE          reduce using rule 6 (stmt -> output_stmt .)
    $end            reduce using rule 6 (stmt -> output_stmt .)
    RBRACE          reduce using rule 6 (stmt -> output_stmt .)


state 7

    (7) stmt -> conditional .

    IDENTIFIER      reduce using rule 7 (stmt -> conditional .)
    PRINT           reduce using rule 7 (stmt -> conditional .)
    IF              reduce using rule 7 (stmt -> conditional .)
    WHILE           reduce using rule 7 (stmt -> conditional .)
    INT             reduce using rule 7 (stmt -> conditional .)
    FLOAT           reduce using rule 7 (stmt -> conditional .)
    LBRACE          reduce using rule 7 (stmt -> conditional .)
    $end            reduce using rule 7 (stmt -> conditional .)
    RBRACE          reduce using rule 7 (stmt -> conditional .)


state 8

    (8) stmt -> loop .

    IDENTIFIER      reduce using rule 8 (stmt -> loop .)
    PRINT           reduce using rule 8 (stmt -> loop .)
    IF              reduce using rule 8 (stmt -> loop .)
    WHILE           reduce using rule 8 (stmt -> loop .)
    INT             reduce using rule 8 (stmt -> loop .)
    FLOAT           reduce using rule 8 (stmt -> loop .)
    LBRACE          reduce using rule 8 (stmt -> loop .)
    $end            reduce using rule 8 (stmt -> loop .)
    RBRACE          reduce using rule 8 (stmt -> loop .)


state 9

    (9) stmt -> code_block .

    IDENTIFIER      reduce using rule 9 (stmt -> code_block .)
    PRINT           reduce using rule 9 (stmt -> code_block .)
    IF              reduce using rule 9 (stmt -> code_block .)
    WHILE           reduce using rule 9 (stmt -> code_block .)
    INT             reduce using rule 9 (stmt -> code_block .)
    FLOAT           reduce using rule 9 (stmt -> code_block .)
    LBRACE          reduce using rule 9 (stmt -> code_block .)
    $end            reduce using rule 9 (stmt -> code_block .)
    RBRACE          reduce using rule 9 (stmt -> code_block .)


state 10

    (10) var_decl -> data_type . IDENTIFIER SEMICOLON
    (11) var_decl -> data_type . IDENTIFIER EQUALS expr SEMICOLON

    IDENTIFIER      shift and go to state 20


state 11

    (14) var_assign -> IDENTIFIER . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 21


state 12

    (15) output_stmt -> PRINT . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 22


state 13

    (16) conditional -> IF . LPAREN comparison RPAREN code_block
    (17) conditional -> IF . LPAREN comparison RPAREN code_block ELSE code_block

    LPAREN          shift and go to state 23


state 14

    (18) loop -> WHILE . LPAREN comparison RPAREN code_block

    LPAREN          shift and go to state 24


state 15

    (19) code_block -> block_start . stmt_sequence block_end
    (2) stmt_sequence -> . stmt_sequence stmt
    (3) stmt_sequence -> . stmt
    (4) stmt -> . var_decl
    (5) stmt -> . var_assign
    (6) stmt -> . output_stmt
    (7) stmt -> . conditional
    (8) stmt -> . loop
    (9) stmt -> . code_block
    (10) var_decl -> . data_type IDENTIFIER SEMICOLON
    (11) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (14) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (15) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (16) conditional -> . IF LPAREN comparison RPAREN code_block
    (17) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (18) loop -> . WHILE LPAREN comparison RPAREN code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (12) data_type -> . INT
    (13) data_type -> . FLOAT
    (20) block_start -> . LBRACE

    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    LBRACE          shift and go to state 18

    block_start                    shift and go to state 15
    stmt_sequence                  shift and go to state 25
    stmt                           shift and go to state 3
    var_decl                       shift and go to state 4
    var_assign                     shift and go to state 5
    output_stmt                    shift and go to state 6
    conditional                    shift and go to state 7
    loop                           shift and go to state 8
    code_block                     shift and go to state 9
    data_type                      shift and go to state 10

state 16

    (12) data_type -> INT .

    IDENTIFIER      reduce using rule 12 (data_type -> INT .)


state 17

    (13) data_type -> FLOAT .

    IDENTIFIER      reduce using rule 13 (data_type -> FLOAT .)


state 18

    (20) block_start -> LBRACE .

    IDENTIFIER      reduce using rule 20 (block_start -> LBRACE .)
    PRINT           reduce using rule 20 (block_start -> LBRACE .)
    IF              reduce using rule 20 (block_start -> LBRACE .)
    WHILE           reduce using rule 20 (block_start -> LBRACE .)
    INT             reduce using rule 20 (block_start -> LBRACE .)
    FLOAT           reduce using rule 20 (block_start -> LBRACE .)
    LBRACE          reduce using rule 20 (block_start -> LBRACE .)


state 19

    (2) stmt_sequence -> stmt_sequence stmt .

    IDENTIFIER      reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    PRINT           reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    IF              reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    WHILE           reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    INT             reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    FLOAT           reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    LBRACE          reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    $end            reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)
    RBRACE          reduce using rule 2 (stmt_sequence -> stmt_sequence stmt .)


state 20

    (10) var_decl -> data_type IDENTIFIER . SEMICOLON
    (11) var_decl -> data_type IDENTIFIER . EQUALS expr SEMICOLON

    SEMICOLON       shift and go to state 26
    EQUALS          shift and go to state 27


state 21

    (14) var_assign -> IDENTIFIER EQUALS . expr SEMICOLON
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    expr                           shift and go to state 29
    term                           shift and go to state 30
    base                           shift and go to state 31

state 22

    (15) output_stmt -> PRINT LPAREN . expr RPAREN SEMICOLON
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    expr                           shift and go to state 35
    term                           shift and go to state 30
    base                           shift and go to state 31

state 23

    (16) conditional -> IF LPAREN . comparison RPAREN code_block
    (17) conditional -> IF LPAREN . comparison RPAREN code_block ELSE code_block
    (22) comparison -> . expr rel_op expr
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    comparison                     shift and go to state 36
    expr                           shift and go to state 37
    term                           shift and go to state 30
    base                           shift and go to state 31

state 24

    (18) loop -> WHILE LPAREN . comparison RPAREN code_block
    (22) comparison -> . expr rel_op expr
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    comparison                     shift and go to state 38
    expr                           shift and go to state 37
    term                           shift and go to state 30
    base                           shift and go to state 31

state 25

    (19) code_block -> block_start stmt_sequence . block_end
    (2) stmt_sequence -> stmt_sequence . stmt
    (21) block_end -> . RBRACE
    (4) stmt -> . var_decl
    (5) stmt -> . var_assign
    (6) stmt -> . output_stmt
    (7) stmt -> . conditional
    (8) stmt -> . loop
    (9) stmt -> . code_block
    (10) var_decl -> . data_type IDENTIFIER SEMICOLON
    (11) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (14) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (15) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (16) conditional -> . IF LPAREN comparison RPAREN code_block
    (17) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (18) loop -> . WHILE LPAREN comparison RPAREN code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (12) data_type -> . INT
    (13) data_type -> . FLOAT
    (20) block_start -> . LBRACE

    RBRACE          shift and go to state 40
    IDENTIFIER      shift and go to state 11
    PRINT           shift and go to state 12
    IF              shift and go to state 13
    WHILE           shift and go to state 14
    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    LBRACE          shift and go to state 18

    block_start                    shift and go to state 15
    block_end                      shift and go to state 39
    stmt                           shift and go to state 19
    var_decl                       shift and go to state 4
    var_assign                     shift and go to state 5
    output_stmt                    shift and go to state 6
    conditional                    shift and go to state 7
    loop                           shift and go to state 8
    code_block                     shift and go to state 9
    data_type                      shift and go to state 10

state 26

    (10) var_decl -> data_type IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    IF              reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    INT             reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 10 (var_decl -> data_type IDENTIFIER SEMICOLON .)


state 27

    (11) var_decl -> data_type IDENTIFIER EQUALS . expr SEMICOLON
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    expr                           shift and go to state 41
    term                           shift and go to state 30
    base                           shift and go to state 31

state 28

    (38) base -> IDENTIFIER .

    MULTIPLY        reduce using rule 38 (base -> IDENTIFIER .)
    DIVIDE          reduce using rule 38 (base -> IDENTIFIER .)
    MOD             reduce using rule 38 (base -> IDENTIFIER .)
    SEMICOLON       reduce using rule 38 (base -> IDENTIFIER .)
    PLUS            reduce using rule 38 (base -> IDENTIFIER .)
    MINUS           reduce using rule 38 (base -> IDENTIFIER .)
    RPAREN          reduce using rule 38 (base -> IDENTIFIER .)
    LESS            reduce using rule 38 (base -> IDENTIFIER .)
    LESS_EQ         reduce using rule 38 (base -> IDENTIFIER .)
    GREATER         reduce using rule 38 (base -> IDENTIFIER .)
    GREATER_EQ      reduce using rule 38 (base -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 38 (base -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 38 (base -> IDENTIFIER .)


state 29

    (14) var_assign -> IDENTIFIER EQUALS expr . SEMICOLON
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 42
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 30

    (31) expr -> term .
    (32) term -> term . MULTIPLY base
    (33) term -> term . DIVIDE base
    (34) term -> term . MOD base

    SEMICOLON       reduce using rule 31 (expr -> term .)
    PLUS            reduce using rule 31 (expr -> term .)
    MINUS           reduce using rule 31 (expr -> term .)
    RPAREN          reduce using rule 31 (expr -> term .)
    LESS            reduce using rule 31 (expr -> term .)
    LESS_EQ         reduce using rule 31 (expr -> term .)
    GREATER         reduce using rule 31 (expr -> term .)
    GREATER_EQ      reduce using rule 31 (expr -> term .)
    EQUAL_TO        reduce using rule 31 (expr -> term .)
    NOT_EQUAL       reduce using rule 31 (expr -> term .)
    MULTIPLY        shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47


state 31

    (35) term -> base .

    MULTIPLY        reduce using rule 35 (term -> base .)
    DIVIDE          reduce using rule 35 (term -> base .)
    MOD             reduce using rule 35 (term -> base .)
    SEMICOLON       reduce using rule 35 (term -> base .)
    PLUS            reduce using rule 35 (term -> base .)
    MINUS           reduce using rule 35 (term -> base .)
    RPAREN          reduce using rule 35 (term -> base .)
    LESS            reduce using rule 35 (term -> base .)
    LESS_EQ         reduce using rule 35 (term -> base .)
    GREATER         reduce using rule 35 (term -> base .)
    GREATER_EQ      reduce using rule 35 (term -> base .)
    EQUAL_TO        reduce using rule 35 (term -> base .)
    NOT_EQUAL       reduce using rule 35 (term -> base .)


state 32

    (36) base -> INTEGER .

    MULTIPLY        reduce using rule 36 (base -> INTEGER .)
    DIVIDE          reduce using rule 36 (base -> INTEGER .)
    MOD             reduce using rule 36 (base -> INTEGER .)
    SEMICOLON       reduce using rule 36 (base -> INTEGER .)
    PLUS            reduce using rule 36 (base -> INTEGER .)
    MINUS           reduce using rule 36 (base -> INTEGER .)
    RPAREN          reduce using rule 36 (base -> INTEGER .)
    LESS            reduce using rule 36 (base -> INTEGER .)
    LESS_EQ         reduce using rule 36 (base -> INTEGER .)
    GREATER         reduce using rule 36 (base -> INTEGER .)
    GREATER_EQ      reduce using rule 36 (base -> INTEGER .)
    EQUAL_TO        reduce using rule 36 (base -> INTEGER .)
    NOT_EQUAL       reduce using rule 36 (base -> INTEGER .)


state 33

    (37) base -> DECIMAL .

    MULTIPLY        reduce using rule 37 (base -> DECIMAL .)
    DIVIDE          reduce using rule 37 (base -> DECIMAL .)
    MOD             reduce using rule 37 (base -> DECIMAL .)
    SEMICOLON       reduce using rule 37 (base -> DECIMAL .)
    PLUS            reduce using rule 37 (base -> DECIMAL .)
    MINUS           reduce using rule 37 (base -> DECIMAL .)
    RPAREN          reduce using rule 37 (base -> DECIMAL .)
    LESS            reduce using rule 37 (base -> DECIMAL .)
    LESS_EQ         reduce using rule 37 (base -> DECIMAL .)
    GREATER         reduce using rule 37 (base -> DECIMAL .)
    GREATER_EQ      reduce using rule 37 (base -> DECIMAL .)
    EQUAL_TO        reduce using rule 37 (base -> DECIMAL .)
    NOT_EQUAL       reduce using rule 37 (base -> DECIMAL .)


state 34

    (39) base -> LPAREN . expr RPAREN
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    expr                           shift and go to state 48
    term                           shift and go to state 30
    base                           shift and go to state 31

state 35

    (15) output_stmt -> PRINT LPAREN expr . RPAREN SEMICOLON
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term

    RPAREN          shift and go to state 49
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 36

    (16) conditional -> IF LPAREN comparison . RPAREN code_block
    (17) conditional -> IF LPAREN comparison . RPAREN code_block ELSE code_block

    RPAREN          shift and go to state 50


state 37

    (22) comparison -> expr . rel_op expr
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term
    (23) rel_op -> . LESS
    (24) rel_op -> . LESS_EQ
    (25) rel_op -> . GREATER
    (26) rel_op -> . GREATER_EQ
    (27) rel_op -> . EQUAL_TO
    (28) rel_op -> . NOT_EQUAL

    PLUS            shift and go to state 43
    MINUS           shift and go to state 44
    LESS            shift and go to state 52
    LESS_EQ         shift and go to state 53
    GREATER         shift and go to state 54
    GREATER_EQ      shift and go to state 55
    EQUAL_TO        shift and go to state 56
    NOT_EQUAL       shift and go to state 57

    rel_op                         shift and go to state 51

state 38

    (18) loop -> WHILE LPAREN comparison . RPAREN code_block

    RPAREN          shift and go to state 58


state 39

    (19) code_block -> block_start stmt_sequence block_end .

    IDENTIFIER      reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    PRINT           reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    IF              reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    WHILE           reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    INT             reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    FLOAT           reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    LBRACE          reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    $end            reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    RBRACE          reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)
    ELSE            reduce using rule 19 (code_block -> block_start stmt_sequence block_end .)


state 40

    (21) block_end -> RBRACE .

    IDENTIFIER      reduce using rule 21 (block_end -> RBRACE .)
    PRINT           reduce using rule 21 (block_end -> RBRACE .)
    IF              reduce using rule 21 (block_end -> RBRACE .)
    WHILE           reduce using rule 21 (block_end -> RBRACE .)
    INT             reduce using rule 21 (block_end -> RBRACE .)
    FLOAT           reduce using rule 21 (block_end -> RBRACE .)
    LBRACE          reduce using rule 21 (block_end -> RBRACE .)
    $end            reduce using rule 21 (block_end -> RBRACE .)
    RBRACE          reduce using rule 21 (block_end -> RBRACE .)
    ELSE            reduce using rule 21 (block_end -> RBRACE .)


state 41

    (11) var_decl -> data_type IDENTIFIER EQUALS expr . SEMICOLON
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 59
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 42

    (14) var_assign -> IDENTIFIER EQUALS expr SEMICOLON .

    IDENTIFIER      reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    PRINT           reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    IF              reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    INT             reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    $end            reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 14 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)


state 43

    (29) expr -> expr PLUS . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    term                           shift and go to state 60
    base                           shift and go to state 31

state 44

    (30) expr -> expr MINUS . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    term                           shift and go to state 61
    base                           shift and go to state 31

state 45

    (32) term -> term MULTIPLY . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    base                           shift and go to state 62

state 46

    (33) term -> term DIVIDE . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    base                           shift and go to state 63

state 47

    (34) term -> term MOD . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    base                           shift and go to state 64

state 48

    (39) base -> LPAREN expr . RPAREN
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term

    RPAREN          shift and go to state 65
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 49

    (15) output_stmt -> PRINT LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 66


state 50

    (16) conditional -> IF LPAREN comparison RPAREN . code_block
    (17) conditional -> IF LPAREN comparison RPAREN . code_block ELSE code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (20) block_start -> . LBRACE

    LBRACE          shift and go to state 18

    code_block                     shift and go to state 67
    block_start                    shift and go to state 15

state 51

    (22) comparison -> expr rel_op . expr
    (29) expr -> . expr PLUS term
    (30) expr -> . expr MINUS term
    (31) expr -> . term
    (32) term -> . term MULTIPLY base
    (33) term -> . term DIVIDE base
    (34) term -> . term MOD base
    (35) term -> . base
    (36) base -> . INTEGER
    (37) base -> . DECIMAL
    (38) base -> . IDENTIFIER
    (39) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 32
    DECIMAL         shift and go to state 33
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 34

    expr                           shift and go to state 68
    term                           shift and go to state 30
    base                           shift and go to state 31

state 52

    (23) rel_op -> LESS .

    INTEGER         reduce using rule 23 (rel_op -> LESS .)
    DECIMAL         reduce using rule 23 (rel_op -> LESS .)
    IDENTIFIER      reduce using rule 23 (rel_op -> LESS .)
    LPAREN          reduce using rule 23 (rel_op -> LESS .)


state 53

    (24) rel_op -> LESS_EQ .

    INTEGER         reduce using rule 24 (rel_op -> LESS_EQ .)
    DECIMAL         reduce using rule 24 (rel_op -> LESS_EQ .)
    IDENTIFIER      reduce using rule 24 (rel_op -> LESS_EQ .)
    LPAREN          reduce using rule 24 (rel_op -> LESS_EQ .)


state 54

    (25) rel_op -> GREATER .

    INTEGER         reduce using rule 25 (rel_op -> GREATER .)
    DECIMAL         reduce using rule 25 (rel_op -> GREATER .)
    IDENTIFIER      reduce using rule 25 (rel_op -> GREATER .)
    LPAREN          reduce using rule 25 (rel_op -> GREATER .)


state 55

    (26) rel_op -> GREATER_EQ .

    INTEGER         reduce using rule 26 (rel_op -> GREATER_EQ .)
    DECIMAL         reduce using rule 26 (rel_op -> GREATER_EQ .)
    IDENTIFIER      reduce using rule 26 (rel_op -> GREATER_EQ .)
    LPAREN          reduce using rule 26 (rel_op -> GREATER_EQ .)


state 56

    (27) rel_op -> EQUAL_TO .

    INTEGER         reduce using rule 27 (rel_op -> EQUAL_TO .)
    DECIMAL         reduce using rule 27 (rel_op -> EQUAL_TO .)
    IDENTIFIER      reduce using rule 27 (rel_op -> EQUAL_TO .)
    LPAREN          reduce using rule 27 (rel_op -> EQUAL_TO .)


state 57

    (28) rel_op -> NOT_EQUAL .

    INTEGER         reduce using rule 28 (rel_op -> NOT_EQUAL .)
    DECIMAL         reduce using rule 28 (rel_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 28 (rel_op -> NOT_EQUAL .)
    LPAREN          reduce using rule 28 (rel_op -> NOT_EQUAL .)


state 58

    (18) loop -> WHILE LPAREN comparison RPAREN . code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (20) block_start -> . LBRACE

    LBRACE          shift and go to state 18

    code_block                     shift and go to state 69
    block_start                    shift and go to state 15

state 59

    (11) var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .

    IDENTIFIER      reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    PRINT           reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    IF              reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    INT             reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    $end            reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 11 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)


state 60

    (29) expr -> expr PLUS term .
    (32) term -> term . MULTIPLY base
    (33) term -> term . DIVIDE base
    (34) term -> term . MOD base

    SEMICOLON       reduce using rule 29 (expr -> expr PLUS term .)
    PLUS            reduce using rule 29 (expr -> expr PLUS term .)
    MINUS           reduce using rule 29 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 29 (expr -> expr PLUS term .)
    LESS            reduce using rule 29 (expr -> expr PLUS term .)
    LESS_EQ         reduce using rule 29 (expr -> expr PLUS term .)
    GREATER         reduce using rule 29 (expr -> expr PLUS term .)
    GREATER_EQ      reduce using rule 29 (expr -> expr PLUS term .)
    EQUAL_TO        reduce using rule 29 (expr -> expr PLUS term .)
    NOT_EQUAL       reduce using rule 29 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47


state 61

    (30) expr -> expr MINUS term .
    (32) term -> term . MULTIPLY base
    (33) term -> term . DIVIDE base
    (34) term -> term . MOD base

    SEMICOLON       reduce using rule 30 (expr -> expr MINUS term .)
    PLUS            reduce using rule 30 (expr -> expr MINUS term .)
    MINUS           reduce using rule 30 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 30 (expr -> expr MINUS term .)
    LESS            reduce using rule 30 (expr -> expr MINUS term .)
    LESS_EQ         reduce using rule 30 (expr -> expr MINUS term .)
    GREATER         reduce using rule 30 (expr -> expr MINUS term .)
    GREATER_EQ      reduce using rule 30 (expr -> expr MINUS term .)
    EQUAL_TO        reduce using rule 30 (expr -> expr MINUS term .)
    NOT_EQUAL       reduce using rule 30 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 45
    DIVIDE          shift and go to state 46
    MOD             shift and go to state 47


state 62

    (32) term -> term MULTIPLY base .

    MULTIPLY        reduce using rule 32 (term -> term MULTIPLY base .)
    DIVIDE          reduce using rule 32 (term -> term MULTIPLY base .)
    MOD             reduce using rule 32 (term -> term MULTIPLY base .)
    SEMICOLON       reduce using rule 32 (term -> term MULTIPLY base .)
    PLUS            reduce using rule 32 (term -> term MULTIPLY base .)
    MINUS           reduce using rule 32 (term -> term MULTIPLY base .)
    RPAREN          reduce using rule 32 (term -> term MULTIPLY base .)
    LESS            reduce using rule 32 (term -> term MULTIPLY base .)
    LESS_EQ         reduce using rule 32 (term -> term MULTIPLY base .)
    GREATER         reduce using rule 32 (term -> term MULTIPLY base .)
    GREATER_EQ      reduce using rule 32 (term -> term MULTIPLY base .)
    EQUAL_TO        reduce using rule 32 (term -> term MULTIPLY base .)
    NOT_EQUAL       reduce using rule 32 (term -> term MULTIPLY base .)


state 63

    (33) term -> term DIVIDE base .

    MULTIPLY        reduce using rule 33 (term -> term DIVIDE base .)
    DIVIDE          reduce using rule 33 (term -> term DIVIDE base .)
    MOD             reduce using rule 33 (term -> term DIVIDE base .)
    SEMICOLON       reduce using rule 33 (term -> term DIVIDE base .)
    PLUS            reduce using rule 33 (term -> term DIVIDE base .)
    MINUS           reduce using rule 33 (term -> term DIVIDE base .)
    RPAREN          reduce using rule 33 (term -> term DIVIDE base .)
    LESS            reduce using rule 33 (term -> term DIVIDE base .)
    LESS_EQ         reduce using rule 33 (term -> term DIVIDE base .)
    GREATER         reduce using rule 33 (term -> term DIVIDE base .)
    GREATER_EQ      reduce using rule 33 (term -> term DIVIDE base .)
    EQUAL_TO        reduce using rule 33 (term -> term DIVIDE base .)
    NOT_EQUAL       reduce using rule 33 (term -> term DIVIDE base .)


state 64

    (34) term -> term MOD base .

    MULTIPLY        reduce using rule 34 (term -> term MOD base .)
    DIVIDE          reduce using rule 34 (term -> term MOD base .)
    MOD             reduce using rule 34 (term -> term MOD base .)
    SEMICOLON       reduce using rule 34 (term -> term MOD base .)
    PLUS            reduce using rule 34 (term -> term MOD base .)
    MINUS           reduce using rule 34 (term -> term MOD base .)
    RPAREN          reduce using rule 34 (term -> term MOD base .)
    LESS            reduce using rule 34 (term -> term MOD base .)
    LESS_EQ         reduce using rule 34 (term -> term MOD base .)
    GREATER         reduce using rule 34 (term -> term MOD base .)
    GREATER_EQ      reduce using rule 34 (term -> term MOD base .)
    EQUAL_TO        reduce using rule 34 (term -> term MOD base .)
    NOT_EQUAL       reduce using rule 34 (term -> term MOD base .)


state 65

    (39) base -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 39 (base -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 39 (base -> LPAREN expr RPAREN .)
    MOD             reduce using rule 39 (base -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 39 (base -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 39 (base -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 39 (base -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 39 (base -> LPAREN expr RPAREN .)
    LESS            reduce using rule 39 (base -> LPAREN expr RPAREN .)
    LESS_EQ         reduce using rule 39 (base -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 39 (base -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 39 (base -> LPAREN expr RPAREN .)
    EQUAL_TO        reduce using rule 39 (base -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 39 (base -> LPAREN expr RPAREN .)


state 66

    (15) output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    PRINT           reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    FLOAT           reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    $end            reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 15 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)


state 67

    (16) conditional -> IF LPAREN comparison RPAREN code_block .
    (17) conditional -> IF LPAREN comparison RPAREN code_block . ELSE code_block

    IDENTIFIER      reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    PRINT           reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    IF              reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    WHILE           reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    INT             reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    FLOAT           reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    LBRACE          reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    $end            reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    RBRACE          reduce using rule 16 (conditional -> IF LPAREN comparison RPAREN code_block .)
    ELSE            shift and go to state 70


state 68

    (22) comparison -> expr rel_op expr .
    (29) expr -> expr . PLUS term
    (30) expr -> expr . MINUS term

    RPAREN          reduce using rule 22 (comparison -> expr rel_op expr .)
    PLUS            shift and go to state 43
    MINUS           shift and go to state 44


state 69

    (18) loop -> WHILE LPAREN comparison RPAREN code_block .

    IDENTIFIER      reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    PRINT           reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    IF              reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    WHILE           reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    INT             reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    FLOAT           reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    LBRACE          reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    $end            reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    RBRACE          reduce using rule 18 (loop -> WHILE LPAREN comparison RPAREN code_block .)


state 70

    (17) conditional -> IF LPAREN comparison RPAREN code_block ELSE . code_block
    (19) code_block -> . block_start stmt_sequence block_end
    (20) block_start -> . LBRACE

    LBRACE          shift and go to state 18

    code_block                     shift and go to state 71
    block_start                    shift and go to state 15

state 71

    (17) conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .

    IDENTIFIER      reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    PRINT           reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    IF              reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    WHILE           reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    INT             reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    FLOAT           reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    LBRACE          reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    $end            reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    RBRACE          reduce using rule 17 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)

