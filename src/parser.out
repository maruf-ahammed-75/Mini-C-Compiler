Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    FOR

Grammar

Rule 0     S' -> start
Rule 1     start -> function_list
Rule 2     start -> stmt_sequence
Rule 3     function_list -> function_list function
Rule 4     function_list -> function
Rule 5     function -> data_type IDENTIFIER LPAREN RPAREN code_block
Rule 6     stmt_sequence -> stmt_sequence stmt
Rule 7     stmt_sequence -> stmt
Rule 8     stmt -> var_decl
Rule 9     stmt -> var_assign
Rule 10    stmt -> output_stmt
Rule 11    stmt -> conditional
Rule 12    stmt -> loop
Rule 13    stmt -> return_stmt
Rule 14    stmt -> code_block
Rule 15    return_stmt -> RETURN expr SEMICOLON
Rule 16    return_stmt -> RETURN SEMICOLON
Rule 17    var_decl -> data_type IDENTIFIER SEMICOLON
Rule 18    var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON
Rule 19    data_type -> INT
Rule 20    data_type -> FLOAT
Rule 21    var_assign -> IDENTIFIER EQUALS expr SEMICOLON
Rule 22    output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON
Rule 23    conditional -> IF LPAREN comparison RPAREN code_block
Rule 24    conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block
Rule 25    loop -> WHILE LPAREN comparison RPAREN code_block
Rule 26    code_block -> block_start stmt_sequence block_end
Rule 27    block_start -> LBRACE
Rule 28    block_end -> RBRACE
Rule 29    comparison -> expr rel_op expr
Rule 30    rel_op -> LESS
Rule 31    rel_op -> LESS_EQ
Rule 32    rel_op -> GREATER
Rule 33    rel_op -> GREATER_EQ
Rule 34    rel_op -> EQUAL_TO
Rule 35    rel_op -> NOT_EQUAL
Rule 36    expr -> expr PLUS term
Rule 37    expr -> expr MINUS term
Rule 38    expr -> term
Rule 39    term -> term MULTIPLY base
Rule 40    term -> term DIVIDE base
Rule 41    term -> term MOD base
Rule 42    term -> base
Rule 43    base -> INTEGER
Rule 44    base -> DECIMAL
Rule 45    base -> IDENTIFIER
Rule 46    base -> LPAREN expr RPAREN

Terminals, with rules where they appear

COMMA                : 
DECIMAL              : 44
DIVIDE               : 40
ELSE                 : 24
EQUALS               : 18 21
EQUAL_TO             : 34
FLOAT                : 20
FOR                  : 
GREATER              : 32
GREATER_EQ           : 33
IDENTIFIER           : 5 17 18 21 45
IF                   : 23 24
INT                  : 19
INTEGER              : 43
LBRACE               : 27
LESS                 : 30
LESS_EQ              : 31
LPAREN               : 5 22 23 24 25 46
MINUS                : 37
MOD                  : 41
MULTIPLY             : 39
NOT_EQUAL            : 35
PLUS                 : 36
PRINT                : 22
RBRACE               : 28
RETURN               : 15 16
RPAREN               : 5 22 23 24 25 46
SEMICOLON            : 15 16 17 18 21 22
WHILE                : 25
error                : 

Nonterminals, with rules where they appear

base                 : 39 40 41 42
block_end            : 26
block_start          : 26
code_block           : 5 14 23 24 24 25
comparison           : 23 24 25
conditional          : 11
data_type            : 5 17 18
expr                 : 15 18 21 22 29 29 36 37 46
function             : 3 4
function_list        : 1 3
loop                 : 12
output_stmt          : 10
rel_op               : 29
return_stmt          : 13
start                : 0
stmt                 : 6 7
stmt_sequence        : 2 6 26
term                 : 36 37 38 39 40 41
var_assign           : 9
var_decl             : 8

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . function_list
    (2) start -> . stmt_sequence
    (3) function_list -> . function_list function
    (4) function_list -> . function
    (6) stmt_sequence -> . stmt_sequence stmt
    (7) stmt_sequence -> . stmt
    (5) function -> . data_type IDENTIFIER LPAREN RPAREN code_block
    (8) stmt -> . var_decl
    (9) stmt -> . var_assign
    (10) stmt -> . output_stmt
    (11) stmt -> . conditional
    (12) stmt -> . loop
    (13) stmt -> . return_stmt
    (14) stmt -> . code_block
    (19) data_type -> . INT
    (20) data_type -> . FLOAT
    (17) var_decl -> . data_type IDENTIFIER SEMICOLON
    (18) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (21) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (22) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (23) conditional -> . IF LPAREN comparison RPAREN code_block
    (24) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (25) loop -> . WHILE LPAREN comparison RPAREN code_block
    (15) return_stmt -> . RETURN expr SEMICOLON
    (16) return_stmt -> . RETURN SEMICOLON
    (26) code_block -> . block_start stmt_sequence block_end
    (27) block_start -> . LBRACE

    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    IDENTIFIER      shift and go to state 7
    PRINT           shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    RETURN          shift and go to state 20
    LBRACE          shift and go to state 22

    start                          shift and go to state 1
    function_list                  shift and go to state 2
    stmt_sequence                  shift and go to state 3
    function                       shift and go to state 4
    stmt                           shift and go to state 5
    data_type                      shift and go to state 6
    code_block                     shift and go to state 8
    var_decl                       shift and go to state 9
    var_assign                     shift and go to state 10
    output_stmt                    shift and go to state 11
    conditional                    shift and go to state 12
    loop                           shift and go to state 13
    return_stmt                    shift and go to state 14
    block_start                    shift and go to state 21

state 1

    (0) S' -> start .



state 2

    (1) start -> function_list .
    (3) function_list -> function_list . function
    (5) function -> . data_type IDENTIFIER LPAREN RPAREN code_block
    (19) data_type -> . INT
    (20) data_type -> . FLOAT

    $end            reduce using rule 1 (start -> function_list .)
    INT             shift and go to state 15
    FLOAT           shift and go to state 16

    function                       shift and go to state 23
    data_type                      shift and go to state 24

state 3

    (2) start -> stmt_sequence .
    (6) stmt_sequence -> stmt_sequence . stmt
    (8) stmt -> . var_decl
    (9) stmt -> . var_assign
    (10) stmt -> . output_stmt
    (11) stmt -> . conditional
    (12) stmt -> . loop
    (13) stmt -> . return_stmt
    (14) stmt -> . code_block
    (17) var_decl -> . data_type IDENTIFIER SEMICOLON
    (18) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (21) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (22) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (23) conditional -> . IF LPAREN comparison RPAREN code_block
    (24) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (25) loop -> . WHILE LPAREN comparison RPAREN code_block
    (15) return_stmt -> . RETURN expr SEMICOLON
    (16) return_stmt -> . RETURN SEMICOLON
    (26) code_block -> . block_start stmt_sequence block_end
    (19) data_type -> . INT
    (20) data_type -> . FLOAT
    (27) block_start -> . LBRACE

    $end            reduce using rule 2 (start -> stmt_sequence .)
    IDENTIFIER      shift and go to state 7
    PRINT           shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    RETURN          shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    LBRACE          shift and go to state 22

    stmt                           shift and go to state 25
    var_decl                       shift and go to state 9
    var_assign                     shift and go to state 10
    output_stmt                    shift and go to state 11
    conditional                    shift and go to state 12
    loop                           shift and go to state 13
    return_stmt                    shift and go to state 14
    code_block                     shift and go to state 8
    data_type                      shift and go to state 26
    block_start                    shift and go to state 21

state 4

    (4) function_list -> function .

    INT             reduce using rule 4 (function_list -> function .)
    FLOAT           reduce using rule 4 (function_list -> function .)
    $end            reduce using rule 4 (function_list -> function .)


state 5

    (7) stmt_sequence -> stmt .

    IDENTIFIER      reduce using rule 7 (stmt_sequence -> stmt .)
    PRINT           reduce using rule 7 (stmt_sequence -> stmt .)
    IF              reduce using rule 7 (stmt_sequence -> stmt .)
    WHILE           reduce using rule 7 (stmt_sequence -> stmt .)
    RETURN          reduce using rule 7 (stmt_sequence -> stmt .)
    INT             reduce using rule 7 (stmt_sequence -> stmt .)
    FLOAT           reduce using rule 7 (stmt_sequence -> stmt .)
    LBRACE          reduce using rule 7 (stmt_sequence -> stmt .)
    $end            reduce using rule 7 (stmt_sequence -> stmt .)
    RBRACE          reduce using rule 7 (stmt_sequence -> stmt .)


state 6

    (5) function -> data_type . IDENTIFIER LPAREN RPAREN code_block
    (17) var_decl -> data_type . IDENTIFIER SEMICOLON
    (18) var_decl -> data_type . IDENTIFIER EQUALS expr SEMICOLON

    IDENTIFIER      shift and go to state 27


state 7

    (21) var_assign -> IDENTIFIER . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 28


state 8

    (14) stmt -> code_block .

    IDENTIFIER      reduce using rule 14 (stmt -> code_block .)
    PRINT           reduce using rule 14 (stmt -> code_block .)
    IF              reduce using rule 14 (stmt -> code_block .)
    WHILE           reduce using rule 14 (stmt -> code_block .)
    RETURN          reduce using rule 14 (stmt -> code_block .)
    INT             reduce using rule 14 (stmt -> code_block .)
    FLOAT           reduce using rule 14 (stmt -> code_block .)
    LBRACE          reduce using rule 14 (stmt -> code_block .)
    $end            reduce using rule 14 (stmt -> code_block .)
    RBRACE          reduce using rule 14 (stmt -> code_block .)


state 9

    (8) stmt -> var_decl .

    IDENTIFIER      reduce using rule 8 (stmt -> var_decl .)
    PRINT           reduce using rule 8 (stmt -> var_decl .)
    IF              reduce using rule 8 (stmt -> var_decl .)
    WHILE           reduce using rule 8 (stmt -> var_decl .)
    RETURN          reduce using rule 8 (stmt -> var_decl .)
    INT             reduce using rule 8 (stmt -> var_decl .)
    FLOAT           reduce using rule 8 (stmt -> var_decl .)
    LBRACE          reduce using rule 8 (stmt -> var_decl .)
    $end            reduce using rule 8 (stmt -> var_decl .)
    RBRACE          reduce using rule 8 (stmt -> var_decl .)


state 10

    (9) stmt -> var_assign .

    IDENTIFIER      reduce using rule 9 (stmt -> var_assign .)
    PRINT           reduce using rule 9 (stmt -> var_assign .)
    IF              reduce using rule 9 (stmt -> var_assign .)
    WHILE           reduce using rule 9 (stmt -> var_assign .)
    RETURN          reduce using rule 9 (stmt -> var_assign .)
    INT             reduce using rule 9 (stmt -> var_assign .)
    FLOAT           reduce using rule 9 (stmt -> var_assign .)
    LBRACE          reduce using rule 9 (stmt -> var_assign .)
    $end            reduce using rule 9 (stmt -> var_assign .)
    RBRACE          reduce using rule 9 (stmt -> var_assign .)


state 11

    (10) stmt -> output_stmt .

    IDENTIFIER      reduce using rule 10 (stmt -> output_stmt .)
    PRINT           reduce using rule 10 (stmt -> output_stmt .)
    IF              reduce using rule 10 (stmt -> output_stmt .)
    WHILE           reduce using rule 10 (stmt -> output_stmt .)
    RETURN          reduce using rule 10 (stmt -> output_stmt .)
    INT             reduce using rule 10 (stmt -> output_stmt .)
    FLOAT           reduce using rule 10 (stmt -> output_stmt .)
    LBRACE          reduce using rule 10 (stmt -> output_stmt .)
    $end            reduce using rule 10 (stmt -> output_stmt .)
    RBRACE          reduce using rule 10 (stmt -> output_stmt .)


state 12

    (11) stmt -> conditional .

    IDENTIFIER      reduce using rule 11 (stmt -> conditional .)
    PRINT           reduce using rule 11 (stmt -> conditional .)
    IF              reduce using rule 11 (stmt -> conditional .)
    WHILE           reduce using rule 11 (stmt -> conditional .)
    RETURN          reduce using rule 11 (stmt -> conditional .)
    INT             reduce using rule 11 (stmt -> conditional .)
    FLOAT           reduce using rule 11 (stmt -> conditional .)
    LBRACE          reduce using rule 11 (stmt -> conditional .)
    $end            reduce using rule 11 (stmt -> conditional .)
    RBRACE          reduce using rule 11 (stmt -> conditional .)


state 13

    (12) stmt -> loop .

    IDENTIFIER      reduce using rule 12 (stmt -> loop .)
    PRINT           reduce using rule 12 (stmt -> loop .)
    IF              reduce using rule 12 (stmt -> loop .)
    WHILE           reduce using rule 12 (stmt -> loop .)
    RETURN          reduce using rule 12 (stmt -> loop .)
    INT             reduce using rule 12 (stmt -> loop .)
    FLOAT           reduce using rule 12 (stmt -> loop .)
    LBRACE          reduce using rule 12 (stmt -> loop .)
    $end            reduce using rule 12 (stmt -> loop .)
    RBRACE          reduce using rule 12 (stmt -> loop .)


state 14

    (13) stmt -> return_stmt .

    IDENTIFIER      reduce using rule 13 (stmt -> return_stmt .)
    PRINT           reduce using rule 13 (stmt -> return_stmt .)
    IF              reduce using rule 13 (stmt -> return_stmt .)
    WHILE           reduce using rule 13 (stmt -> return_stmt .)
    RETURN          reduce using rule 13 (stmt -> return_stmt .)
    INT             reduce using rule 13 (stmt -> return_stmt .)
    FLOAT           reduce using rule 13 (stmt -> return_stmt .)
    LBRACE          reduce using rule 13 (stmt -> return_stmt .)
    $end            reduce using rule 13 (stmt -> return_stmt .)
    RBRACE          reduce using rule 13 (stmt -> return_stmt .)


state 15

    (19) data_type -> INT .

    IDENTIFIER      reduce using rule 19 (data_type -> INT .)


state 16

    (20) data_type -> FLOAT .

    IDENTIFIER      reduce using rule 20 (data_type -> FLOAT .)


state 17

    (22) output_stmt -> PRINT . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 29


state 18

    (23) conditional -> IF . LPAREN comparison RPAREN code_block
    (24) conditional -> IF . LPAREN comparison RPAREN code_block ELSE code_block

    LPAREN          shift and go to state 30


state 19

    (25) loop -> WHILE . LPAREN comparison RPAREN code_block

    LPAREN          shift and go to state 31


state 20

    (15) return_stmt -> RETURN . expr SEMICOLON
    (16) return_stmt -> RETURN . SEMICOLON
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    SEMICOLON       shift and go to state 33
    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 32
    term                           shift and go to state 34
    base                           shift and go to state 35

state 21

    (26) code_block -> block_start . stmt_sequence block_end
    (6) stmt_sequence -> . stmt_sequence stmt
    (7) stmt_sequence -> . stmt
    (8) stmt -> . var_decl
    (9) stmt -> . var_assign
    (10) stmt -> . output_stmt
    (11) stmt -> . conditional
    (12) stmt -> . loop
    (13) stmt -> . return_stmt
    (14) stmt -> . code_block
    (17) var_decl -> . data_type IDENTIFIER SEMICOLON
    (18) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (21) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (22) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (23) conditional -> . IF LPAREN comparison RPAREN code_block
    (24) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (25) loop -> . WHILE LPAREN comparison RPAREN code_block
    (15) return_stmt -> . RETURN expr SEMICOLON
    (16) return_stmt -> . RETURN SEMICOLON
    (26) code_block -> . block_start stmt_sequence block_end
    (19) data_type -> . INT
    (20) data_type -> . FLOAT
    (27) block_start -> . LBRACE

    IDENTIFIER      shift and go to state 7
    PRINT           shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    RETURN          shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    LBRACE          shift and go to state 22

    block_start                    shift and go to state 21
    stmt_sequence                  shift and go to state 40
    stmt                           shift and go to state 5
    var_decl                       shift and go to state 9
    var_assign                     shift and go to state 10
    output_stmt                    shift and go to state 11
    conditional                    shift and go to state 12
    loop                           shift and go to state 13
    return_stmt                    shift and go to state 14
    code_block                     shift and go to state 8
    data_type                      shift and go to state 26

state 22

    (27) block_start -> LBRACE .

    IDENTIFIER      reduce using rule 27 (block_start -> LBRACE .)
    PRINT           reduce using rule 27 (block_start -> LBRACE .)
    IF              reduce using rule 27 (block_start -> LBRACE .)
    WHILE           reduce using rule 27 (block_start -> LBRACE .)
    RETURN          reduce using rule 27 (block_start -> LBRACE .)
    INT             reduce using rule 27 (block_start -> LBRACE .)
    FLOAT           reduce using rule 27 (block_start -> LBRACE .)
    LBRACE          reduce using rule 27 (block_start -> LBRACE .)


state 23

    (3) function_list -> function_list function .

    INT             reduce using rule 3 (function_list -> function_list function .)
    FLOAT           reduce using rule 3 (function_list -> function_list function .)
    $end            reduce using rule 3 (function_list -> function_list function .)


state 24

    (5) function -> data_type . IDENTIFIER LPAREN RPAREN code_block

    IDENTIFIER      shift and go to state 41


state 25

    (6) stmt_sequence -> stmt_sequence stmt .

    IDENTIFIER      reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    PRINT           reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    IF              reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    WHILE           reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    RETURN          reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    INT             reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    FLOAT           reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    LBRACE          reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    $end            reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)
    RBRACE          reduce using rule 6 (stmt_sequence -> stmt_sequence stmt .)


state 26

    (17) var_decl -> data_type . IDENTIFIER SEMICOLON
    (18) var_decl -> data_type . IDENTIFIER EQUALS expr SEMICOLON

    IDENTIFIER      shift and go to state 42


state 27

    (5) function -> data_type IDENTIFIER . LPAREN RPAREN code_block
    (17) var_decl -> data_type IDENTIFIER . SEMICOLON
    (18) var_decl -> data_type IDENTIFIER . EQUALS expr SEMICOLON

    LPAREN          shift and go to state 43
    SEMICOLON       shift and go to state 44
    EQUALS          shift and go to state 45


state 28

    (21) var_assign -> IDENTIFIER EQUALS . expr SEMICOLON
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 46
    term                           shift and go to state 34
    base                           shift and go to state 35

state 29

    (22) output_stmt -> PRINT LPAREN . expr RPAREN SEMICOLON
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 47
    term                           shift and go to state 34
    base                           shift and go to state 35

state 30

    (23) conditional -> IF LPAREN . comparison RPAREN code_block
    (24) conditional -> IF LPAREN . comparison RPAREN code_block ELSE code_block
    (29) comparison -> . expr rel_op expr
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    comparison                     shift and go to state 48
    expr                           shift and go to state 49
    term                           shift and go to state 34
    base                           shift and go to state 35

state 31

    (25) loop -> WHILE LPAREN . comparison RPAREN code_block
    (29) comparison -> . expr rel_op expr
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    comparison                     shift and go to state 50
    expr                           shift and go to state 49
    term                           shift and go to state 34
    base                           shift and go to state 35

state 32

    (15) return_stmt -> RETURN expr . SEMICOLON
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 51
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 33

    (16) return_stmt -> RETURN SEMICOLON .

    IDENTIFIER      reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    PRINT           reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    $end            reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)
    RBRACE          reduce using rule 16 (return_stmt -> RETURN SEMICOLON .)


state 34

    (38) expr -> term .
    (39) term -> term . MULTIPLY base
    (40) term -> term . DIVIDE base
    (41) term -> term . MOD base

    SEMICOLON       reduce using rule 38 (expr -> term .)
    PLUS            reduce using rule 38 (expr -> term .)
    MINUS           reduce using rule 38 (expr -> term .)
    RPAREN          reduce using rule 38 (expr -> term .)
    LESS            reduce using rule 38 (expr -> term .)
    LESS_EQ         reduce using rule 38 (expr -> term .)
    GREATER         reduce using rule 38 (expr -> term .)
    GREATER_EQ      reduce using rule 38 (expr -> term .)
    EQUAL_TO        reduce using rule 38 (expr -> term .)
    NOT_EQUAL       reduce using rule 38 (expr -> term .)
    MULTIPLY        shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 35

    (42) term -> base .

    MULTIPLY        reduce using rule 42 (term -> base .)
    DIVIDE          reduce using rule 42 (term -> base .)
    MOD             reduce using rule 42 (term -> base .)
    SEMICOLON       reduce using rule 42 (term -> base .)
    PLUS            reduce using rule 42 (term -> base .)
    MINUS           reduce using rule 42 (term -> base .)
    RPAREN          reduce using rule 42 (term -> base .)
    LESS            reduce using rule 42 (term -> base .)
    LESS_EQ         reduce using rule 42 (term -> base .)
    GREATER         reduce using rule 42 (term -> base .)
    GREATER_EQ      reduce using rule 42 (term -> base .)
    EQUAL_TO        reduce using rule 42 (term -> base .)
    NOT_EQUAL       reduce using rule 42 (term -> base .)


state 36

    (43) base -> INTEGER .

    MULTIPLY        reduce using rule 43 (base -> INTEGER .)
    DIVIDE          reduce using rule 43 (base -> INTEGER .)
    MOD             reduce using rule 43 (base -> INTEGER .)
    SEMICOLON       reduce using rule 43 (base -> INTEGER .)
    PLUS            reduce using rule 43 (base -> INTEGER .)
    MINUS           reduce using rule 43 (base -> INTEGER .)
    RPAREN          reduce using rule 43 (base -> INTEGER .)
    LESS            reduce using rule 43 (base -> INTEGER .)
    LESS_EQ         reduce using rule 43 (base -> INTEGER .)
    GREATER         reduce using rule 43 (base -> INTEGER .)
    GREATER_EQ      reduce using rule 43 (base -> INTEGER .)
    EQUAL_TO        reduce using rule 43 (base -> INTEGER .)
    NOT_EQUAL       reduce using rule 43 (base -> INTEGER .)


state 37

    (44) base -> DECIMAL .

    MULTIPLY        reduce using rule 44 (base -> DECIMAL .)
    DIVIDE          reduce using rule 44 (base -> DECIMAL .)
    MOD             reduce using rule 44 (base -> DECIMAL .)
    SEMICOLON       reduce using rule 44 (base -> DECIMAL .)
    PLUS            reduce using rule 44 (base -> DECIMAL .)
    MINUS           reduce using rule 44 (base -> DECIMAL .)
    RPAREN          reduce using rule 44 (base -> DECIMAL .)
    LESS            reduce using rule 44 (base -> DECIMAL .)
    LESS_EQ         reduce using rule 44 (base -> DECIMAL .)
    GREATER         reduce using rule 44 (base -> DECIMAL .)
    GREATER_EQ      reduce using rule 44 (base -> DECIMAL .)
    EQUAL_TO        reduce using rule 44 (base -> DECIMAL .)
    NOT_EQUAL       reduce using rule 44 (base -> DECIMAL .)


state 38

    (45) base -> IDENTIFIER .

    MULTIPLY        reduce using rule 45 (base -> IDENTIFIER .)
    DIVIDE          reduce using rule 45 (base -> IDENTIFIER .)
    MOD             reduce using rule 45 (base -> IDENTIFIER .)
    SEMICOLON       reduce using rule 45 (base -> IDENTIFIER .)
    PLUS            reduce using rule 45 (base -> IDENTIFIER .)
    MINUS           reduce using rule 45 (base -> IDENTIFIER .)
    RPAREN          reduce using rule 45 (base -> IDENTIFIER .)
    LESS            reduce using rule 45 (base -> IDENTIFIER .)
    LESS_EQ         reduce using rule 45 (base -> IDENTIFIER .)
    GREATER         reduce using rule 45 (base -> IDENTIFIER .)
    GREATER_EQ      reduce using rule 45 (base -> IDENTIFIER .)
    EQUAL_TO        reduce using rule 45 (base -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 45 (base -> IDENTIFIER .)


state 39

    (46) base -> LPAREN . expr RPAREN
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 57
    term                           shift and go to state 34
    base                           shift and go to state 35

state 40

    (26) code_block -> block_start stmt_sequence . block_end
    (6) stmt_sequence -> stmt_sequence . stmt
    (28) block_end -> . RBRACE
    (8) stmt -> . var_decl
    (9) stmt -> . var_assign
    (10) stmt -> . output_stmt
    (11) stmt -> . conditional
    (12) stmt -> . loop
    (13) stmt -> . return_stmt
    (14) stmt -> . code_block
    (17) var_decl -> . data_type IDENTIFIER SEMICOLON
    (18) var_decl -> . data_type IDENTIFIER EQUALS expr SEMICOLON
    (21) var_assign -> . IDENTIFIER EQUALS expr SEMICOLON
    (22) output_stmt -> . PRINT LPAREN expr RPAREN SEMICOLON
    (23) conditional -> . IF LPAREN comparison RPAREN code_block
    (24) conditional -> . IF LPAREN comparison RPAREN code_block ELSE code_block
    (25) loop -> . WHILE LPAREN comparison RPAREN code_block
    (15) return_stmt -> . RETURN expr SEMICOLON
    (16) return_stmt -> . RETURN SEMICOLON
    (26) code_block -> . block_start stmt_sequence block_end
    (19) data_type -> . INT
    (20) data_type -> . FLOAT
    (27) block_start -> . LBRACE

    RBRACE          shift and go to state 59
    IDENTIFIER      shift and go to state 7
    PRINT           shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 19
    RETURN          shift and go to state 20
    INT             shift and go to state 15
    FLOAT           shift and go to state 16
    LBRACE          shift and go to state 22

    block_start                    shift and go to state 21
    block_end                      shift and go to state 58
    stmt                           shift and go to state 25
    var_decl                       shift and go to state 9
    var_assign                     shift and go to state 10
    output_stmt                    shift and go to state 11
    conditional                    shift and go to state 12
    loop                           shift and go to state 13
    return_stmt                    shift and go to state 14
    code_block                     shift and go to state 8
    data_type                      shift and go to state 26

state 41

    (5) function -> data_type IDENTIFIER . LPAREN RPAREN code_block

    LPAREN          shift and go to state 43


state 42

    (17) var_decl -> data_type IDENTIFIER . SEMICOLON
    (18) var_decl -> data_type IDENTIFIER . EQUALS expr SEMICOLON

    SEMICOLON       shift and go to state 44
    EQUALS          shift and go to state 45


state 43

    (5) function -> data_type IDENTIFIER LPAREN . RPAREN code_block

    RPAREN          shift and go to state 60


state 44

    (17) var_decl -> data_type IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    PRINT           reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    IF              reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    INT             reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 17 (var_decl -> data_type IDENTIFIER SEMICOLON .)


state 45

    (18) var_decl -> data_type IDENTIFIER EQUALS . expr SEMICOLON
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 61
    term                           shift and go to state 34
    base                           shift and go to state 35

state 46

    (21) var_assign -> IDENTIFIER EQUALS expr . SEMICOLON
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 62
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 47

    (22) output_stmt -> PRINT LPAREN expr . RPAREN SEMICOLON
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    RPAREN          shift and go to state 63
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 48

    (23) conditional -> IF LPAREN comparison . RPAREN code_block
    (24) conditional -> IF LPAREN comparison . RPAREN code_block ELSE code_block

    RPAREN          shift and go to state 64


state 49

    (29) comparison -> expr . rel_op expr
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term
    (30) rel_op -> . LESS
    (31) rel_op -> . LESS_EQ
    (32) rel_op -> . GREATER
    (33) rel_op -> . GREATER_EQ
    (34) rel_op -> . EQUAL_TO
    (35) rel_op -> . NOT_EQUAL

    PLUS            shift and go to state 52
    MINUS           shift and go to state 53
    LESS            shift and go to state 66
    LESS_EQ         shift and go to state 67
    GREATER         shift and go to state 68
    GREATER_EQ      shift and go to state 69
    EQUAL_TO        shift and go to state 70
    NOT_EQUAL       shift and go to state 71

    rel_op                         shift and go to state 65

state 50

    (25) loop -> WHILE LPAREN comparison . RPAREN code_block

    RPAREN          shift and go to state 72


state 51

    (15) return_stmt -> RETURN expr SEMICOLON .

    IDENTIFIER      reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    PRINT           reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    $end            reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)
    RBRACE          reduce using rule 15 (return_stmt -> RETURN expr SEMICOLON .)


state 52

    (36) expr -> expr PLUS . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    term                           shift and go to state 73
    base                           shift and go to state 35

state 53

    (37) expr -> expr MINUS . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    term                           shift and go to state 74
    base                           shift and go to state 35

state 54

    (39) term -> term MULTIPLY . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    base                           shift and go to state 75

state 55

    (40) term -> term DIVIDE . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    base                           shift and go to state 76

state 56

    (41) term -> term MOD . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    base                           shift and go to state 77

state 57

    (46) base -> LPAREN expr . RPAREN
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    RPAREN          shift and go to state 78
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 58

    (26) code_block -> block_start stmt_sequence block_end .

    IDENTIFIER      reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    PRINT           reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    IF              reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    WHILE           reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    RETURN          reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    INT             reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    FLOAT           reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    LBRACE          reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    $end            reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    RBRACE          reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)
    ELSE            reduce using rule 26 (code_block -> block_start stmt_sequence block_end .)


state 59

    (28) block_end -> RBRACE .

    IDENTIFIER      reduce using rule 28 (block_end -> RBRACE .)
    PRINT           reduce using rule 28 (block_end -> RBRACE .)
    IF              reduce using rule 28 (block_end -> RBRACE .)
    WHILE           reduce using rule 28 (block_end -> RBRACE .)
    RETURN          reduce using rule 28 (block_end -> RBRACE .)
    INT             reduce using rule 28 (block_end -> RBRACE .)
    FLOAT           reduce using rule 28 (block_end -> RBRACE .)
    LBRACE          reduce using rule 28 (block_end -> RBRACE .)
    $end            reduce using rule 28 (block_end -> RBRACE .)
    RBRACE          reduce using rule 28 (block_end -> RBRACE .)
    ELSE            reduce using rule 28 (block_end -> RBRACE .)


state 60

    (5) function -> data_type IDENTIFIER LPAREN RPAREN . code_block
    (26) code_block -> . block_start stmt_sequence block_end
    (27) block_start -> . LBRACE

    LBRACE          shift and go to state 22

    code_block                     shift and go to state 79
    block_start                    shift and go to state 21

state 61

    (18) var_decl -> data_type IDENTIFIER EQUALS expr . SEMICOLON
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    SEMICOLON       shift and go to state 80
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 62

    (21) var_assign -> IDENTIFIER EQUALS expr SEMICOLON .

    IDENTIFIER      reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    PRINT           reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    IF              reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    INT             reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    $end            reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 21 (var_assign -> IDENTIFIER EQUALS expr SEMICOLON .)


state 63

    (22) output_stmt -> PRINT LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 81


state 64

    (23) conditional -> IF LPAREN comparison RPAREN . code_block
    (24) conditional -> IF LPAREN comparison RPAREN . code_block ELSE code_block
    (26) code_block -> . block_start stmt_sequence block_end
    (27) block_start -> . LBRACE

    LBRACE          shift and go to state 22

    code_block                     shift and go to state 82
    block_start                    shift and go to state 21

state 65

    (29) comparison -> expr rel_op . expr
    (36) expr -> . expr PLUS term
    (37) expr -> . expr MINUS term
    (38) expr -> . term
    (39) term -> . term MULTIPLY base
    (40) term -> . term DIVIDE base
    (41) term -> . term MOD base
    (42) term -> . base
    (43) base -> . INTEGER
    (44) base -> . DECIMAL
    (45) base -> . IDENTIFIER
    (46) base -> . LPAREN expr RPAREN

    INTEGER         shift and go to state 36
    DECIMAL         shift and go to state 37
    IDENTIFIER      shift and go to state 38
    LPAREN          shift and go to state 39

    expr                           shift and go to state 83
    term                           shift and go to state 34
    base                           shift and go to state 35

state 66

    (30) rel_op -> LESS .

    INTEGER         reduce using rule 30 (rel_op -> LESS .)
    DECIMAL         reduce using rule 30 (rel_op -> LESS .)
    IDENTIFIER      reduce using rule 30 (rel_op -> LESS .)
    LPAREN          reduce using rule 30 (rel_op -> LESS .)


state 67

    (31) rel_op -> LESS_EQ .

    INTEGER         reduce using rule 31 (rel_op -> LESS_EQ .)
    DECIMAL         reduce using rule 31 (rel_op -> LESS_EQ .)
    IDENTIFIER      reduce using rule 31 (rel_op -> LESS_EQ .)
    LPAREN          reduce using rule 31 (rel_op -> LESS_EQ .)


state 68

    (32) rel_op -> GREATER .

    INTEGER         reduce using rule 32 (rel_op -> GREATER .)
    DECIMAL         reduce using rule 32 (rel_op -> GREATER .)
    IDENTIFIER      reduce using rule 32 (rel_op -> GREATER .)
    LPAREN          reduce using rule 32 (rel_op -> GREATER .)


state 69

    (33) rel_op -> GREATER_EQ .

    INTEGER         reduce using rule 33 (rel_op -> GREATER_EQ .)
    DECIMAL         reduce using rule 33 (rel_op -> GREATER_EQ .)
    IDENTIFIER      reduce using rule 33 (rel_op -> GREATER_EQ .)
    LPAREN          reduce using rule 33 (rel_op -> GREATER_EQ .)


state 70

    (34) rel_op -> EQUAL_TO .

    INTEGER         reduce using rule 34 (rel_op -> EQUAL_TO .)
    DECIMAL         reduce using rule 34 (rel_op -> EQUAL_TO .)
    IDENTIFIER      reduce using rule 34 (rel_op -> EQUAL_TO .)
    LPAREN          reduce using rule 34 (rel_op -> EQUAL_TO .)


state 71

    (35) rel_op -> NOT_EQUAL .

    INTEGER         reduce using rule 35 (rel_op -> NOT_EQUAL .)
    DECIMAL         reduce using rule 35 (rel_op -> NOT_EQUAL .)
    IDENTIFIER      reduce using rule 35 (rel_op -> NOT_EQUAL .)
    LPAREN          reduce using rule 35 (rel_op -> NOT_EQUAL .)


state 72

    (25) loop -> WHILE LPAREN comparison RPAREN . code_block
    (26) code_block -> . block_start stmt_sequence block_end
    (27) block_start -> . LBRACE

    LBRACE          shift and go to state 22

    code_block                     shift and go to state 84
    block_start                    shift and go to state 21

state 73

    (36) expr -> expr PLUS term .
    (39) term -> term . MULTIPLY base
    (40) term -> term . DIVIDE base
    (41) term -> term . MOD base

    SEMICOLON       reduce using rule 36 (expr -> expr PLUS term .)
    PLUS            reduce using rule 36 (expr -> expr PLUS term .)
    MINUS           reduce using rule 36 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 36 (expr -> expr PLUS term .)
    LESS            reduce using rule 36 (expr -> expr PLUS term .)
    LESS_EQ         reduce using rule 36 (expr -> expr PLUS term .)
    GREATER         reduce using rule 36 (expr -> expr PLUS term .)
    GREATER_EQ      reduce using rule 36 (expr -> expr PLUS term .)
    EQUAL_TO        reduce using rule 36 (expr -> expr PLUS term .)
    NOT_EQUAL       reduce using rule 36 (expr -> expr PLUS term .)
    MULTIPLY        shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 74

    (37) expr -> expr MINUS term .
    (39) term -> term . MULTIPLY base
    (40) term -> term . DIVIDE base
    (41) term -> term . MOD base

    SEMICOLON       reduce using rule 37 (expr -> expr MINUS term .)
    PLUS            reduce using rule 37 (expr -> expr MINUS term .)
    MINUS           reduce using rule 37 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 37 (expr -> expr MINUS term .)
    LESS            reduce using rule 37 (expr -> expr MINUS term .)
    LESS_EQ         reduce using rule 37 (expr -> expr MINUS term .)
    GREATER         reduce using rule 37 (expr -> expr MINUS term .)
    GREATER_EQ      reduce using rule 37 (expr -> expr MINUS term .)
    EQUAL_TO        reduce using rule 37 (expr -> expr MINUS term .)
    NOT_EQUAL       reduce using rule 37 (expr -> expr MINUS term .)
    MULTIPLY        shift and go to state 54
    DIVIDE          shift and go to state 55
    MOD             shift and go to state 56


state 75

    (39) term -> term MULTIPLY base .

    MULTIPLY        reduce using rule 39 (term -> term MULTIPLY base .)
    DIVIDE          reduce using rule 39 (term -> term MULTIPLY base .)
    MOD             reduce using rule 39 (term -> term MULTIPLY base .)
    SEMICOLON       reduce using rule 39 (term -> term MULTIPLY base .)
    PLUS            reduce using rule 39 (term -> term MULTIPLY base .)
    MINUS           reduce using rule 39 (term -> term MULTIPLY base .)
    RPAREN          reduce using rule 39 (term -> term MULTIPLY base .)
    LESS            reduce using rule 39 (term -> term MULTIPLY base .)
    LESS_EQ         reduce using rule 39 (term -> term MULTIPLY base .)
    GREATER         reduce using rule 39 (term -> term MULTIPLY base .)
    GREATER_EQ      reduce using rule 39 (term -> term MULTIPLY base .)
    EQUAL_TO        reduce using rule 39 (term -> term MULTIPLY base .)
    NOT_EQUAL       reduce using rule 39 (term -> term MULTIPLY base .)


state 76

    (40) term -> term DIVIDE base .

    MULTIPLY        reduce using rule 40 (term -> term DIVIDE base .)
    DIVIDE          reduce using rule 40 (term -> term DIVIDE base .)
    MOD             reduce using rule 40 (term -> term DIVIDE base .)
    SEMICOLON       reduce using rule 40 (term -> term DIVIDE base .)
    PLUS            reduce using rule 40 (term -> term DIVIDE base .)
    MINUS           reduce using rule 40 (term -> term DIVIDE base .)
    RPAREN          reduce using rule 40 (term -> term DIVIDE base .)
    LESS            reduce using rule 40 (term -> term DIVIDE base .)
    LESS_EQ         reduce using rule 40 (term -> term DIVIDE base .)
    GREATER         reduce using rule 40 (term -> term DIVIDE base .)
    GREATER_EQ      reduce using rule 40 (term -> term DIVIDE base .)
    EQUAL_TO        reduce using rule 40 (term -> term DIVIDE base .)
    NOT_EQUAL       reduce using rule 40 (term -> term DIVIDE base .)


state 77

    (41) term -> term MOD base .

    MULTIPLY        reduce using rule 41 (term -> term MOD base .)
    DIVIDE          reduce using rule 41 (term -> term MOD base .)
    MOD             reduce using rule 41 (term -> term MOD base .)
    SEMICOLON       reduce using rule 41 (term -> term MOD base .)
    PLUS            reduce using rule 41 (term -> term MOD base .)
    MINUS           reduce using rule 41 (term -> term MOD base .)
    RPAREN          reduce using rule 41 (term -> term MOD base .)
    LESS            reduce using rule 41 (term -> term MOD base .)
    LESS_EQ         reduce using rule 41 (term -> term MOD base .)
    GREATER         reduce using rule 41 (term -> term MOD base .)
    GREATER_EQ      reduce using rule 41 (term -> term MOD base .)
    EQUAL_TO        reduce using rule 41 (term -> term MOD base .)
    NOT_EQUAL       reduce using rule 41 (term -> term MOD base .)


state 78

    (46) base -> LPAREN expr RPAREN .

    MULTIPLY        reduce using rule 46 (base -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 46 (base -> LPAREN expr RPAREN .)
    MOD             reduce using rule 46 (base -> LPAREN expr RPAREN .)
    SEMICOLON       reduce using rule 46 (base -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 46 (base -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 46 (base -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 46 (base -> LPAREN expr RPAREN .)
    LESS            reduce using rule 46 (base -> LPAREN expr RPAREN .)
    LESS_EQ         reduce using rule 46 (base -> LPAREN expr RPAREN .)
    GREATER         reduce using rule 46 (base -> LPAREN expr RPAREN .)
    GREATER_EQ      reduce using rule 46 (base -> LPAREN expr RPAREN .)
    EQUAL_TO        reduce using rule 46 (base -> LPAREN expr RPAREN .)
    NOT_EQUAL       reduce using rule 46 (base -> LPAREN expr RPAREN .)


state 79

    (5) function -> data_type IDENTIFIER LPAREN RPAREN code_block .

    INT             reduce using rule 5 (function -> data_type IDENTIFIER LPAREN RPAREN code_block .)
    FLOAT           reduce using rule 5 (function -> data_type IDENTIFIER LPAREN RPAREN code_block .)
    $end            reduce using rule 5 (function -> data_type IDENTIFIER LPAREN RPAREN code_block .)


state 80

    (18) var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .

    IDENTIFIER      reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    PRINT           reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    IF              reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    INT             reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    LBRACE          reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    $end            reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)
    RBRACE          reduce using rule 18 (var_decl -> data_type IDENTIFIER EQUALS expr SEMICOLON .)


state 81

    (22) output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    PRINT           reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    FLOAT           reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    LBRACE          reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    $end            reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)
    RBRACE          reduce using rule 22 (output_stmt -> PRINT LPAREN expr RPAREN SEMICOLON .)


state 82

    (23) conditional -> IF LPAREN comparison RPAREN code_block .
    (24) conditional -> IF LPAREN comparison RPAREN code_block . ELSE code_block

    IDENTIFIER      reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    PRINT           reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    IF              reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    WHILE           reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    RETURN          reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    INT             reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    FLOAT           reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    LBRACE          reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    $end            reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    RBRACE          reduce using rule 23 (conditional -> IF LPAREN comparison RPAREN code_block .)
    ELSE            shift and go to state 85


state 83

    (29) comparison -> expr rel_op expr .
    (36) expr -> expr . PLUS term
    (37) expr -> expr . MINUS term

    RPAREN          reduce using rule 29 (comparison -> expr rel_op expr .)
    PLUS            shift and go to state 52
    MINUS           shift and go to state 53


state 84

    (25) loop -> WHILE LPAREN comparison RPAREN code_block .

    IDENTIFIER      reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    PRINT           reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    IF              reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    WHILE           reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    RETURN          reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    INT             reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    FLOAT           reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    LBRACE          reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    $end            reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)
    RBRACE          reduce using rule 25 (loop -> WHILE LPAREN comparison RPAREN code_block .)


state 85

    (24) conditional -> IF LPAREN comparison RPAREN code_block ELSE . code_block
    (26) code_block -> . block_start stmt_sequence block_end
    (27) block_start -> . LBRACE

    LBRACE          shift and go to state 22

    code_block                     shift and go to state 86
    block_start                    shift and go to state 21

state 86

    (24) conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .

    IDENTIFIER      reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    PRINT           reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    IF              reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    WHILE           reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    RETURN          reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    INT             reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    FLOAT           reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    LBRACE          reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    $end            reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)
    RBRACE          reduce using rule 24 (conditional -> IF LPAREN comparison RPAREN code_block ELSE code_block .)

